
/**
 * Copyright (C) 2017  Ardika Rommy Sanjaya
 */

buildscript {

	apply from: "${rootDir}/gradle/configure.gradle"

	repositories {
		jcenter()
	}

	dependencies {
		classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
	}

}

allprojects {

	apply plugin: 'java'
	apply plugin: 'maven'
	apply plugin: 'signing'
	apply plugin: 'jacoco'
	apply plugin: 'com.jfrog.bintray'

	group = "${GROUP}"
	version = "${VERSION}"

	sourceCompatibility = "${JAVA_VERSION}"
	targetCompatibility = "${JAVA_VERSION}"

	[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

	repositories {
		jcenter()
	}

	configurations.archives.artifacts.with { archives ->
		def jarArtifact
		archives.each {
			if (it.file =~ 'jar' && project.name == "${rootProject.name}") {
				jarArtifact = it
			}
		}
		remove(jarArtifact)
	}

	if (project.name != "${rootProject.name}") {

		javadoc {
			def currentYear = Calendar.getInstance().get Calendar.YEAR
			options.with {
				locale 'en_US'
				encoding 'UTF-8'
				charSet 'UTF-8'
				author true
				windowTitle "${NAME} ${project.version}"
				header "${NAME} ${project.version}"
				docTitle "${NAME} ${project.version} API Documentation"
				footer 'https://github.com/ardikars/Jxnet'
				bottom "Copyright &copy; 2015 - ${currentYear} ardikars.com. All rights reserved."
				showFromProtected()
				addStringOption 'Xdoclint:all,-reference', '-quiet'
			}
		}	

		task javadocJar(type: Jar) {
			classifier = 'javadoc'
			from javadoc
		}

		task sourcesJar(type: Jar) {
			classifier = 'sources'
			from sourceSets.main.allSource
		}

		tasks.withType(JavaCompile) {
			options.compilerArgs << "-Xlint:unchecked" << "-Werror"
		}

		artifacts {
			archives jar, sourcesJar, javadocJar
		}

	} else {	
		jar.enabled = false
		task javadocJar(type: Jar) {
			classifier = 'javadoc'
			from javadoc
		}
		artifacts {
			archives javadocJar
		}
	}

	signing {
		required { !version.endsWith('SNAPSHOT') && gradle.taskGraph.hasTask('uploadArchives') }
		sign configurations.archives
	}

	install {
		System.setProperty('maven.repo.local', "${MAVEN_LOCAL_REPOSITORY}")
		repositories.mavenInstaller {
			pom.project pom_project
		}
	}

	uploadArchives {	
		repositories.mavenDeployer {
			beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
			repository(url: 'https://oss.sonatype.org/service/local/staging/deploy/maven2/') {
				authentication(userName: defaultBlank({ sonatypeUser }), password: defaultBlank({ sonatypePass }))
			}
			snapshotRepository(url: 'https://oss.sonatype.org/content/repositories/snapshots/') {
				authentication(userName: defaultBlank({ sonatypeUser }), password: defaultBlank({ sonatypePass }))
			}
			pom.project pom_project
		}
	}

	bintray {
		user = defaultBlank({ bintrayUser })
		key = defaultBlank({ bintrayPass })
		configurations = ['archives']
		dryRun = false
		publish = true
		override = true
		pkg {
			repo = 'maven'
			name = 'com.ardikars.jxnet'
			desc = 'Jxnet is a java library for capturing and sending network paket.'
			licenses = ['GNU Lesser General Public License, Version 3.0']
			vcsUrl = 'https://github.com/ardikars/Jxnet.git'
			version {
				name = project.version
				vcsTag = project.version
				gpg {
					sign = true
					passphrase = defaultBlank({ signing.password })
				}
				mavenCentralSync {
					sync = true
					user = defaultBlank({ sonatypeUser })
					password = defaultBlank({ sonatypePass })
					close = '1'
				}
			}
		}
	}

}

subprojects.each {
	subproject -> evaluationDependsOn(subproject.path)
}

javadoc.dependsOn subprojects.tasks['javadoc']

javadocJar {
	subprojects.each { subproject ->
		classifier = 'javadoc'
		from subproject.javadoc
	}
}

task codeCoverageReport(type: JacocoReport) {
	executionData fileTree(project.rootDir.absolutePath).include("**/build/jacoco/*.exec")
	subprojects.each { subproject ->
		if (subproject.name != "${rootProject.name}") {
			sourceSets subproject.sourceSets.main
		}
	}
	reports {
		xml.enabled false
		html.enabled true
		csv.enabled false
	}
}

codeCoverageReport.dependsOn {
	subprojects*.test
}

dependencies {
	compile project(':jxnet-core')
	compile project(':jxnet-packet')
	compile project(':jxnet-util')
}

task distributions(type: Zip, dependsOn: build) {

	archiveName = "${NAME}-${VERSION}.zip"
	
	subprojects.each { subproject ->
		from subproject.jar.outputs.files
		from subproject.javadocJar.outputs.files
		from subproject.sourcesJar.outputs.files
	}

}

task ndkBuild(type: Exec) {
	commandLine "${NDK_HOME}/ndk-build", '-C', "${TOOLS_DIR}",
		"NDK_LIBS_OUT=${TOOLS_OUT}", "NDK_OUT=${TOOLS_OBJ}"
	dependsOn ':jxnet-core:generateJNIHeaders'
	commandLine "${NDK_HOME}/ndk-build", '-C', "${rootDir}",
			"NDK_LIBS_OUT=${JXNET_OUT}", "NDK_OUT=${JXNET_OBJ}"
}

clean {
	dependsOn subprojects.tasks['clean']
	file("${rootDir}/out").deleteDir()
	file("${rootDir}/obj").deleteDir()
	file("${rootDir}/jni/Makefile").delete()
	file("${rootDir}/jni/src/Makefile").delete()
	file("${rootDir}/jni/Makefile.in").delete()
	file("${rootDir}/jni/src/Makefile.in").delete()
	file("${rootDir}/jni/aclocal.m4").delete()
	file("${rootDir}/jni/compile").delete()
	file("${rootDir}/jni/config.guess").delete()
	file("${rootDir}/jni/config.log").delete()
	file("${rootDir}/jni/config.status").delete()
	file("${rootDir}/jni/configure").delete()
	file("${rootDir}/jni/depcomp").delete()
	file("${rootDir}/jni/install-sh").delete()
	file("${rootDir}/jni/libtool").delete()
	file("${rootDir}/jni/ltmain.sh").delete()
	file("${rootDir}/jni/missing").delete()
	file("${rootDir}/jni/config.sub").delete()
	file("${rootDir}/jni/autom4te.cache").deleteDir()
	file("${rootDir}/jni/.autotools").delete()
	file("${rootDir}/jni/jxnet-1.1.0.tar.gz").delete()
	file("${rootDir}/jni/src/.deps").deleteDir()
	file("${rootDir}/jni/src/.libs").deleteDir()
	delete fileTree("${rootDir}/jni/src") { include '**/*.o'
		include '**/*.lo'
		include '**/*.la'
	}
	file("${rootDir}/tools/jni/progs/capsh").delete()
	file("${rootDir}/tools/jni/progs/getcap").delete()
	file("${rootDir}/tools/jni/progs/getpcaps").delete()
	file("${rootDir}/tools/jni/progs/setcap").delete()
	file("${rootDir}/tools/obj").deleteDir()
	file("${rootDir}/tools/jni/libcap/libcap.pc").delete()
	file("${rootDir}/tools/jni/libcap/libcap.so").delete()
	file("${rootDir}/tools/jni/libcap/libcap.so.2").delete()
	file("${rootDir}/tools/jni/libcap/libcap.so.2.25").delete()
	file("${rootDir}/tools/jni/libcap/_makenames").delete()
	file("${rootDir}/tools/build").deleteDir()
}

task wrapper(type: Wrapper) {
	distributionUrl = "https://services.gradle.org/distributions/gradle-${GRADLE_VERSION}-all.zip"
}

